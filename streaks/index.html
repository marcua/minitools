<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#FAFBFC">
    <title>Streaks</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="apple-touch-icon" href="icon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500&family=JetBrains+Mono:wght@400;500&family=Outfit:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --paper: #FAFBFC;
            --paper-warm: #F6F5F3;
            --surface: #FFFFFF;
            --border: #E1E4E8;
            --border-strong: #D0D4D9;

            --ink: #1B2631;
            --ink-secondary: #57606A;
            --ink-muted: #8B949E;
            --ink-faint: #B8BFC6;

            --signal: #0D9488;
            --signal-light: #0D948815;
            --signal-medium: #0D948830;
            --signal-hover: #0B7A70;

            --warm: #D97706;
            --danger: #DC2626;
            --success: #059669;

            --shadow-sm: 0 1px 2px rgba(27, 38, 49, 0.04);
            --shadow-md: 0 2px 8px rgba(27, 38, 49, 0.06), 0 1px 2px rgba(27, 38, 49, 0.04);
            --shadow-lg: 0 8px 24px rgba(27, 38, 49, 0.08), 0 2px 8px rgba(27, 38, 49, 0.04);

            --font-display: 'Outfit', system-ui, sans-serif;
            --font-body: 'DM Sans', system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;

            --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
            --duration-fast: 120ms;
            --duration-normal: 200ms;
            --duration-slow: 350ms;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-body);
            background-color: var(--paper);
            background-image: radial-gradient(ellipse at 50% -20%, var(--signal-light) 0%, transparent 50%);
            color: var(--ink);
            min-height: 100vh;
            line-height: 1.5;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Page titles */
        h1 {
            font-family: var(--font-display);
            font-size: 1.75rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            color: var(--ink);
            margin-top: 48px;
            margin-bottom: 0.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        h2 {
            font-family: var(--font-display);
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            color: var(--ink);
            margin-bottom: 0.75rem;
        }

        h3 {
            font-family: var(--font-body);
            font-size: 1.05rem;
            font-weight: 500;
            color: var(--ink);
            margin-bottom: 0.5rem;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
            animation: fadeIn var(--duration-normal) var(--ease-out);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Form elements */
        label {
            display: block;
            font-family: var(--font-body);
            font-weight: 500;
            font-size: 0.85rem;
            color: var(--ink-secondary);
            margin-bottom: 6px;
        }

        input[type="text"],
        input[type="url"],
        input[type="date"],
        textarea,
        select {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: var(--font-body);
            font-size: 16px;
            background: var(--surface);
            color: var(--ink);
            margin-bottom: 1rem;
            transition: border-color var(--duration-fast), box-shadow var(--duration-fast);
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--signal);
            box-shadow: 0 0 0 3px var(--signal-light);
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 24px;
            background: var(--signal);
            color: white;
            border: none;
            border-radius: 8px;
            font-family: var(--font-body);
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            touch-action: manipulation;
            min-height: 48px;
            transition: background var(--duration-fast), transform var(--duration-fast), box-shadow var(--duration-fast);
        }

        .btn:hover {
            background: var(--signal-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: transparent;
            color: var(--ink-secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--paper-warm);
            transform: translateY(-1px);
        }

        .btn-danger {
            background: var(--danger);
        }

        .btn-danger:hover {
            background: #B91C1C;
        }

        .btn-small {
            padding: 8px 14px;
            font-size: 14px;
            min-height: 40px;
        }

        .btn-group {
            display: flex;
            gap: 12px;
            margin-top: 1rem;
        }

        .btn-group-right {
            justify-content: flex-end;
        }

        /* Toggle button group (Segmented Control) */
        .toggle-group {
            display: flex;
            gap: 0;
            margin-bottom: 1rem;
            background: var(--paper-warm);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 4px;
        }

        .toggle-group .toggle-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            background: transparent;
            color: var(--ink-secondary);
            font-family: var(--font-body);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all var(--duration-normal) var(--ease-spring);
        }

        .toggle-group .toggle-btn.active {
            background: var(--surface);
            color: var(--ink);
            box-shadow: var(--shadow-sm);
        }

        .toggle-group .toggle-btn:not(.active):hover {
            color: var(--ink);
        }

        /* Cards */
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 18px 22px;
            margin-bottom: 10px;
            box-shadow: var(--shadow-sm);
            transition: box-shadow var(--duration-fast), border-color var(--duration-fast);
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            border-color: var(--border-strong);
        }

        /* Goal items */
        .goal-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: var(--shadow-sm);
            transition: all var(--duration-fast);
        }

        .goal-item:hover {
            box-shadow: var(--shadow-md);
            border-color: var(--border-strong);
        }

        .goal-item.dragging {
            opacity: 0.5;
            border-style: dashed;
        }

        .goal-item.drag-over {
            border-color: var(--signal);
            background: var(--signal-light);
        }

        .goal-item .drag-handle {
            cursor: grab;
            color: var(--ink-faint);
            padding: 8px;
            -webkit-user-select: none;
            user-select: none;
            opacity: 0;
            transition: opacity var(--duration-fast);
        }

        .goal-item:hover .drag-handle {
            opacity: 1;
        }

        .goal-item .goal-info {
            flex: 1;
        }

        .goal-item .goal-name {
            font-family: var(--font-body);
            font-weight: 500;
            font-size: 1.05rem;
            color: var(--ink);
        }

        .goal-item .goal-frequency {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--ink-muted);
            margin-top: 2px;
        }

        .goal-item .goal-actions {
            display: flex;
            gap: 8px;
        }

        .goal-item.archived {
            opacity: 0.5;
        }

        /* Today's checklist */
        .checklist-item {
            display: flex;
            align-items: flex-start;
            gap: 14px;
            padding: 18px 22px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: var(--shadow-sm);
            transition: all var(--duration-fast);
            animation: cardFadeIn var(--duration-slow) var(--ease-out) backwards;
        }

        .checklist-item:nth-child(1) { animation-delay: 0ms; }
        .checklist-item:nth-child(2) { animation-delay: 30ms; }
        .checklist-item:nth-child(3) { animation-delay: 60ms; }
        .checklist-item:nth-child(4) { animation-delay: 90ms; }
        .checklist-item:nth-child(5) { animation-delay: 120ms; }
        .checklist-item:nth-child(n+6) { animation-delay: 150ms; }

        @keyframes cardFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .checklist-item:hover {
            box-shadow: var(--shadow-md);
            border-color: var(--border-strong);
        }

        .checklist-item.completed {
            border-left: 3px solid var(--signal);
            background: var(--signal-light);
            border-color: transparent;
            border-left-color: var(--signal);
        }

        .checklist-checkbox {
            width: 24px;
            height: 24px;
            border: 1.5px solid var(--border-strong);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            background: var(--surface);
            touch-action: manipulation;
            margin-top: 2px;
            transition: all var(--duration-fast) var(--ease-spring);
        }

        .checklist-checkbox:hover {
            border-color: var(--signal);
        }

        .checklist-item.completed .checklist-checkbox {
            background: var(--signal);
            border-color: var(--signal);
            color: white;
            animation: checkBounce var(--duration-normal) var(--ease-spring);
        }

        @keyframes checkBounce {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .checklist-checkbox svg {
            width: 14px;
            height: 14px;
        }

        .checklist-content {
            flex: 1;
        }

        .checklist-name-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .checklist-name {
            font-family: var(--font-body);
            font-weight: 500;
            font-size: 1.05rem;
            color: var(--ink);
            margin-bottom: 2px;
        }

        .checklist-frequency {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--ink-muted);
        }

        .checklist-note {
            margin-top: 12px;
        }

        .checklist-note textarea {
            margin-bottom: 0;
            min-height: 60px;
            background: var(--paper-warm);
            font-style: italic;
        }

        .checklist-note textarea::placeholder {
            color: var(--ink-faint);
            font-style: italic;
        }

        .note-display {
            margin-top: 12px;
            padding: 10px 14px;
            background: var(--paper-warm);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.875rem;
            color: var(--ink-secondary);
            cursor: pointer;
            transition: border-color var(--duration-fast);
        }

        .note-display:hover {
            border-color: var(--signal);
        }

        .note-display a {
            color: var(--signal);
        }

        .note-placeholder {
            color: var(--ink-faint);
            font-style: italic;
        }

        .note-edit-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
            color: var(--ink-faint);
            cursor: pointer;
            border-radius: 4px;
            flex-shrink: 0;
            transition: color var(--duration-fast), background var(--duration-fast);
        }

        .note-edit-icon:hover {
            color: var(--signal);
            background: var(--paper-warm);
        }

        .note-edit-icon svg {
            width: 14px;
            height: 14px;
        }

        .note-inline-editor {
            margin-top: 12px;
        }

        .note-inline-editor textarea {
            margin-bottom: 8px;
            min-height: 60px;
            background: var(--paper-warm);
            font-size: 0.875rem;
        }

        .note-inline-editor textarea::placeholder {
            color: var(--ink-faint);
            font-style: italic;
        }

        .note-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .note-actions .btn {
            padding: 6px 12px;
            font-size: 13px;
            min-height: 32px;
        }

        /* Streak visualization */
        .streak-section {
            margin-top: 2.5rem;
        }

        .streak-chart {
            margin-bottom: 2rem;
            animation: cardFadeIn var(--duration-slow) var(--ease-out) backwards;
        }

        .streak-title {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }

        .streak-title h3 {
            margin-bottom: 0;
        }

        .streak-count {
            font-family: var(--font-mono);
            font-size: 0.875rem;
        }

        .streak-count .numerator {
            color: var(--signal);
            font-weight: 500;
        }

        .streak-count .denominator {
            color: var(--ink-muted);
        }

        .streak-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }

        /* Daily grid: 7 rows (days of week) flowing into columns (weeks) */
        .streak-grid.daily {
            display: grid;
            grid-template-rows: repeat(7, 1fr);
            grid-auto-flow: column;
            grid-auto-columns: min-content;
            gap: 2px;
        }

        /* Cells for daily grid - sized to fit ~54 columns in container */
        .streak-grid.daily .streak-cell {
            width: 8px;
            height: 8px;
        }

        .streak-cell {
            width: 11px;
            height: 11px;
            border-radius: 2px;
            background: var(--border);
            cursor: pointer;
            transition: transform var(--duration-fast) var(--ease-spring);
        }

        .streak-cell:hover {
            transform: scale(1.3);
            z-index: 1;
        }

        .streak-cell.filled {
            background: var(--signal);
        }

        .streak-cell.future {
            background: transparent;
            border: 1px dashed var(--border);
        }

        .streak-cell.missed {
            background: var(--paper-warm);
            border: 1px dashed var(--border);
        }

        .streak-cell.has-note {
            background: var(--signal-light);
            border: 1px solid var(--signal);
        }

        .streak-cell.today {
            box-shadow: 0 0 0 2px var(--signal-medium);
            transform: scale(1.1);
        }

        .streak-cell.placeholder {
            visibility: hidden;
        }

        /* Weekly/Monthly streaks */
        .streak-grid.weekly .streak-cell,
        .streak-grid.monthly .streak-cell {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        /* Month labels */
        .month-labels {
            display: flex;
            margin-bottom: 6px;
            padding-left: 0;
        }

        .month-label {
            font-family: var(--font-mono);
            font-size: 0.65rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--ink-muted);
        }

        /* Streak popover */
        .streak-popover {
            display: none;
            position: fixed;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            max-width: 280px;
            box-shadow: var(--shadow-md);
            z-index: 200;
            animation: popoverIn var(--duration-fast) var(--ease-out);
        }

        @keyframes popoverIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .streak-popover.active {
            display: block;
        }

        .streak-popover-date {
            font-family: var(--font-mono);
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--ink);
            margin-bottom: 4px;
        }

        .streak-popover-note {
            font-size: 0.875rem;
            color: var(--ink-secondary);
            word-wrap: break-word;
        }

        .streak-popover-note a {
            color: var(--signal);
        }

        .streak-popover-empty {
            font-size: 0.875rem;
            color: var(--ink-muted);
            font-style: italic;
        }

        /* Year links */
        .year-links {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            font-family: var(--font-mono);
            font-size: 0.875rem;
        }

        .year-links strong {
            color: var(--ink-secondary);
            font-weight: 500;
        }

        .year-links a {
            display: inline-block;
            margin-left: 12px;
            color: var(--signal);
            text-decoration: none;
            transition: color var(--duration-fast);
        }

        .year-links a:hover {
            color: var(--signal-hover);
            text-decoration: underline;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(27, 38, 49, 0.4);
            z-index: 100;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(2px);
        }

        .modal-overlay.active {
            display: flex;
            animation: modalFadeIn var(--duration-normal) var(--ease-out);
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: var(--surface);
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            animation: modalSlideIn var(--duration-normal) var(--ease-spring);
        }

        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .modal h2 {
            margin-bottom: 1.25rem;
        }

        /* Date navigation */
        .date-nav {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            margin-bottom: 1.5rem;
            margin-top: 1rem;
        }

        .date-nav-day {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--ink-muted);
        }

        .date-nav-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .date-nav-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--ink-faint);
            font-size: 1.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: color var(--duration-fast), background var(--duration-fast);
        }

        .date-nav-btn:hover {
            color: var(--signal);
            background: var(--paper-warm);
        }

        .date-nav-btn svg {
            width: 20px;
            height: 20px;
        }

        .date-picker-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            padding: 8px 16px;
            border-radius: 20px;
            background: transparent;
            transition: background var(--duration-fast);
        }

        .date-picker-wrapper:hover {
            background: var(--paper-warm);
        }

        .date-picker-wrapper input[type="date"] {
            font-family: var(--font-mono);
            font-size: 1rem;
            font-weight: 500;
            padding: 0;
            margin: 0;
            border: none;
            background: transparent;
            color: var(--ink);
            cursor: pointer;
            text-align: center;
            width: auto;
        }

        .date-picker-wrapper input[type="date"]:focus {
            outline: none;
            box-shadow: none;
        }

        .date-picker-wrapper input[type="date"]::-webkit-calendar-picker-indicator {
            opacity: 0;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Links */
        .edit-link {
            display: inline-block;
            font-family: var(--font-body);
            font-size: 0.9rem;
            color: var(--signal);
            text-decoration: none;
            margin-bottom: 1.5rem;
            transition: color var(--duration-fast);
        }

        .edit-link:hover {
            color: var(--signal-hover);
            text-decoration: underline;
        }

        /* Error message */
        .error-message {
            background: #FEF2F2;
            border: 1px solid var(--danger);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 1rem;
            color: var(--danger);
            font-size: 0.9rem;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem 2rem;
            color: var(--ink-secondary);
        }

        .empty-state-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 1.5rem;
            color: var(--border-strong);
        }

        .empty-state-icon .accent {
            color: var(--signal);
        }

        .empty-state-title {
            font-family: var(--font-display);
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--ink-secondary);
            margin-bottom: 0.5rem;
        }

        .empty-state-text {
            color: var(--ink-muted);
            margin-bottom: 1.5rem;
        }

        .empty-state a {
            color: var(--signal);
        }

        /* Section divider */
        .section-divider {
            margin: 2rem 0;
            border: none;
            border-top: 1px solid var(--border);
        }

        /* Archive section */
        .archive-section {
            margin-top: 2rem;
        }

        .archive-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-family: var(--font-body);
            font-size: 0.875rem;
            color: var(--ink-muted);
            cursor: pointer;
            padding: 8px 0;
            transition: color var(--duration-fast);
        }

        .archive-toggle:hover {
            color: var(--ink-secondary);
        }

        .archive-toggle svg {
            width: 16px;
            height: 16px;
            transition: transform var(--duration-fast);
        }

        .archive-toggle.expanded svg {
            transform: rotate(180deg);
        }

        .archive-divider {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 1.5rem 0 1rem;
        }

        .archive-divider::before,
        .archive-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }

        .archive-divider span {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--ink-muted);
        }

        .archived-goals {
            margin-top: 1rem;
        }

        /* Mobile responsive */
        @media (max-width: 480px) {
            .container {
                padding: 16px;
            }

            h1 {
                margin-top: 32px;
            }

            .checklist-item,
            .goal-item {
                padding: 14px 16px;
                margin-left: -16px;
                margin-right: -16px;
                border-radius: 0;
                border-left: none;
                border-right: none;
            }

            .checklist-item.completed {
                border-left: 3px solid var(--signal);
            }

            .streak-grid.daily {
                gap: 1px;
            }

            .streak-grid.daily .streak-cell {
                width: 4px;
                height: 4px;
                border-radius: 1px;
            }

            .goal-item .drag-handle {
                opacity: 1;
            }

            .goal-item .goal-actions {
                flex-direction: column;
                gap: 6px;
            }

            .goal-item .goal-actions .btn {
                width: 100%;
            }
        }

        @media (min-width: 481px) and (max-width: 768px) {
            .container {
                max-width: 540px;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus states */
        .btn:focus-visible,
        .checklist-checkbox:focus-visible,
        .date-nav-btn:focus-visible,
        .toggle-btn:focus-visible {
            outline: 2px solid var(--signal);
            outline-offset: 2px;
        }

        /* Setup screen specifics */
        #setup-screen .container {
            max-width: 400px;
        }

        #setup-screen p {
            color: var(--ink-secondary);
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body>
    <!-- SVG Icon Sprite -->
    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
        <symbol id="icon-check" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="20 6 9 17 4 12"></polyline>
        </symbol>
        <symbol id="icon-chevron-left" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 18 9 12 15 6"></polyline>
        </symbol>
        <symbol id="icon-chevron-right" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="9 18 15 12 9 6"></polyline>
        </symbol>
        <symbol id="icon-chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="6 9 12 15 18 9"></polyline>
        </symbol>
        <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </symbol>
        <symbol id="icon-edit" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
        </symbol>
        <symbol id="icon-archive" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="21 8 21 21 3 21 3 8"></polyline>
            <rect x="1" y="3" width="22" height="5"></rect>
            <line x1="10" y1="12" x2="14" y2="12"></line>
        </symbol>
        <symbol id="icon-unarchive" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="21 8 21 21 3 21 3 8"></polyline>
            <rect x="1" y="3" width="22" height="5"></rect>
            <polyline points="12 17 12 11"></polyline>
            <polyline points="9 14 12 11 15 14"></polyline>
        </symbol>
        <symbol id="icon-drag" viewBox="0 0 24 24" fill="currentColor">
            <circle cx="9" cy="6" r="1.5"></circle>
            <circle cx="15" cy="6" r="1.5"></circle>
            <circle cx="9" cy="12" r="1.5"></circle>
            <circle cx="15" cy="12" r="1.5"></circle>
            <circle cx="9" cy="18" r="1.5"></circle>
            <circle cx="15" cy="18" r="1.5"></circle>
        </symbol>
        <symbol id="icon-clipboard" viewBox="0 0 80 80" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="16" y="12" width="48" height="60" rx="4"></rect>
            <rect x="28" y="6" width="24" height="12" rx="2"></rect>
            <line x1="28" y1="32" x2="52" y2="32" class="accent" stroke="var(--signal)"></line>
            <polyline points="26 42 30 46 38 38" class="accent" stroke="var(--signal)"></polyline>
            <line x1="44" y1="42" x2="52" y2="42"></line>
            <polyline points="26 54 30 58 38 50" class="accent" stroke="var(--signal)"></polyline>
            <line x1="44" y1="54" x2="52" y2="54"></line>
        </symbol>
    </svg>

    <!-- Setup Screen -->
    <div id="setup-screen" class="screen">
        <div class="container">
            <h1>Streaks</h1>
            <p>Connect to your ayb database to get started.</p>

            <form id="setup-form">
                <label for="db-url">Database URL</label>
                <input type="url" id="db-url" placeholder="https://host/entity/database" required>

                <label for="api-token">API token</label>
                <input type="text" id="api-token" placeholder="Your API token" required>

                <div class="btn-group btn-group-right">
                    <button type="submit" class="btn">Connect</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Error Screen -->
    <div id="error-screen" class="screen">
        <div class="container">
            <h1>Connection error</h1>
            <div class="error-message" id="error-message"></div>
            <div class="btn-group">
                <button class="btn btn-secondary" id="change-db-btn">Use different database</button>
                <button class="btn" id="retry-btn">Try again</button>
            </div>
        </div>
    </div>

    <!-- Main Screen (Today's Goals) -->
    <div id="main-screen" class="screen">
        <div class="container">
            <h1>Streaks</h1>

            <div class="date-nav">
                <div class="date-nav-day" id="date-day-label"></div>
                <div class="date-nav-row">
                    <button class="date-nav-btn" id="date-prev" aria-label="Previous day">
                        <svg><use href="#icon-chevron-left"/></svg>
                    </button>
                    <div class="date-picker-wrapper">
                        <input type="date" id="date-picker">
                    </div>
                    <button class="date-nav-btn" id="date-next" aria-label="Next day">
                        <svg><use href="#icon-chevron-right"/></svg>
                    </button>
                </div>
            </div>

            <a href="#goals" class="edit-link">Edit goals</a>

            <div id="checklist"></div>

            <hr class="section-divider">

            <div class="streak-section">
                <h2 id="current-year-title"></h2>
                <div id="streak-charts"></div>
            </div>

            <div class="year-links" id="year-links"></div>
        </div>
    </div>

    <!-- Goals Management Screen -->
    <div id="goals-screen" class="screen">
        <div class="container">
            <h1>Goals</h1>
            <a href="#" class="edit-link">&larr; Back to today</a>

            <div class="btn-group" style="margin-bottom: 1.5rem;">
                <button class="btn" id="add-goal-btn">
                    <svg style="width: 18px; height: 18px; margin-right: 8px;"><use href="#icon-plus"/></svg>
                    Add goal
                </button>
            </div>

            <div id="goals-list"></div>

            <div class="archive-section">
                <div class="archive-toggle" id="archive-toggle">
                    <svg><use href="#icon-chevron-down"/></svg>
                    <span>Show archived</span>
                </div>
                <div class="archived-goals" id="archived-goals" style="display: none;"></div>
            </div>
        </div>
    </div>

    <!-- Year View Screen -->
    <div id="year-screen" class="screen">
        <div class="container">
            <h1 id="year-title"></h1>
            <a href="#" class="edit-link">&larr; Back to today</a>

            <div id="year-streak-charts"></div>
        </div>
    </div>

    <!-- Goal Modal -->
    <div class="modal-overlay" id="goal-modal">
        <div class="modal">
            <h2 id="goal-modal-title">Add goal</h2>
            <form id="goal-form">
                <input type="hidden" id="goal-id">

                <label for="goal-name">Goal name</label>
                <input type="text" id="goal-name" required>

                <label>Frequency</label>
                <div class="toggle-group" id="goal-frequency">
                    <button type="button" class="toggle-btn active" data-value="daily">Daily</button>
                    <button type="button" class="toggle-btn" data-value="weekly">Weekly</button>
                    <button type="button" class="toggle-btn" data-value="monthly">Monthly</button>
                </div>

                <div class="btn-group">
                    <button type="button" class="btn btn-secondary" id="cancel-goal-btn">Cancel</button>
                    <button type="submit" class="btn">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirm-modal">
        <div class="modal">
            <h2 id="confirm-title">Confirm</h2>
            <p id="confirm-message" style="color: var(--ink-secondary); margin-bottom: 1rem;"></p>
            <div class="btn-group">
                <button class="btn btn-secondary" id="confirm-cancel">Cancel</button>
                <button class="btn btn-danger" id="confirm-ok">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Streak Popover -->
    <div class="streak-popover" id="streak-popover">
        <div class="streak-popover-date" id="popover-date"></div>
        <div id="popover-content"></div>
    </div>

    <script>
        // ============ Configuration ============
        const APP_NAME = 'streaks';

        // ============ SQL Utilities ============
        function escapeSQL(str) {
            if (str === null || str === undefined) return '';
            return String(str).replace(/'/g, "''");
        }

        function escapeHtml(str) {
            if (str === null || str === undefined) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Simple markdown to HTML (links only)
        function renderMarkdown(text) {
            if (!text) return '';
            let html = escapeHtml(text);
            // Convert URLs to links
            html = html.replace(
                /\[([^\]]+)\]\(([^)]+)\)/g,
                '<a href="$2" target="_blank" rel="noopener">$1</a>'
            );
            // Convert bare URLs to links
            html = html.replace(
                /(https?:\/\/[^\s<]+)/g,
                '<a href="$1" target="_blank" rel="noopener">$1</a>'
            );
            // Convert newlines to <br>
            html = html.replace(/\n/g, '<br>');
            return html;
        }

        // ============ Date Utilities ============
        function getLocalDate(date = new Date()) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function parseLocalDate(dateStr) {
            const [year, month, day] = dateStr.split('-').map(Number);
            return new Date(year, month - 1, day);
        }

        function localToUTC(dateStr) {
            const date = parseLocalDate(dateStr);
            return date.toISOString().split('T')[0];
        }

        function formatDateDisplay(dateStr) {
            const date = parseLocalDate(dateStr);
            const today = new Date();
            const todayStr = getLocalDate(today);

            if (dateStr === todayStr) return 'Today';

            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            if (dateStr === getLocalDate(yesterday)) return 'Yesterday';

            return date.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric'
            });
        }

        function getDayOfWeek(dateStr) {
            const date = parseLocalDate(dateStr);
            return date.toLocaleDateString('en-US', { weekday: 'long' }).toUpperCase();
        }

        function formatDateNav(dateStr) {
            const date = parseLocalDate(dateStr);
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = date.getFullYear();
            return `${month} / ${day} / ${year}`;
        }

        function getWeekNumber(date) {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0);
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            const yearStart = new Date(d.getFullYear(), 0, 1);
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            return Math.floor(diff / (1000 * 60 * 60 * 24));
        }

        // ============ Database ============
        const DB = {
            config: null,

            init() {
                const saved = localStorage.getItem(`${APP_NAME}_config`);
                if (saved) {
                    this.config = JSON.parse(saved);
                    return true;
                }
                return false;
            },

            saveConfig(url, token) {
                const urlObj = new URL(url);
                const pathParts = urlObj.pathname.split('/').filter(p => p);

                let baseUrl, entity, database;

                if (pathParts.length >= 3 && pathParts[0] === 'v1') {
                    // Format: https://host/v1/entity/database
                    entity = pathParts[1];
                    database = pathParts[2];
                    baseUrl = urlObj.origin;
                } else if (pathParts.length >= 2) {
                    // Format: https://host/entity/database
                    entity = pathParts[0];
                    database = pathParts[1];
                    baseUrl = urlObj.origin;
                } else {
                    throw new Error('Invalid URL format. Expected: https://host/entity/database');
                }

                this.config = { baseUrl, entity, database, token };
                localStorage.setItem(`${APP_NAME}_config`, JSON.stringify(this.config));
            },

            clearConfig() {
                this.config = null;
                localStorage.removeItem(`${APP_NAME}_config`);
            },

            async query(sql) {
                if (!this.config) throw new Error('Database not configured');

                const { baseUrl, entity, database, token } = this.config;
                const url = `${baseUrl}/v1/${entity}/${database}/query`;

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'text/plain'
                    },
                    body: sql
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Query failed: ${text}`);
                }

                return response.json();
            }
        };

        // ============ Migrations ============
        const migrations = [
            // v0: Initial schema
            `CREATE TABLE IF NOT EXISTS goals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                frequency TEXT NOT NULL CHECK(frequency IN ('daily', 'weekly', 'monthly')),
                position INTEGER NOT NULL DEFAULT 0,
                archived INTEGER NOT NULL DEFAULT 0,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                updated_at TEXT DEFAULT CURRENT_TIMESTAMP
            )`,
            `CREATE TABLE IF NOT EXISTS completions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                goal_id INTEGER NOT NULL,
                date TEXT NOT NULL,
                note TEXT,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (goal_id) REFERENCES goals(id),
                UNIQUE(goal_id, date)
            )`,
            `CREATE INDEX IF NOT EXISTS idx_completions_date ON completions(date)`,
            `CREATE INDEX IF NOT EXISTS idx_completions_goal ON completions(goal_id)`,
            // v4: Add checked column to allow notes without completion
            `ALTER TABLE completions ADD COLUMN checked INTEGER NOT NULL DEFAULT 1`
        ];

        async function runMigrations() {
            // Create migrations table
            await DB.query(`CREATE TABLE IF NOT EXISTS _migrations (
                version INTEGER PRIMARY KEY,
                applied_at TEXT DEFAULT CURRENT_TIMESTAMP
            )`);

            // Get current version
            const result = await DB.query('SELECT MAX(version) as version FROM _migrations');
            let currentVersion = parseInt(result.rows?.[0]?.[0], 10) || 0;

            // Auto-repair if version is invalid
            if (currentVersion > migrations.length) {
                await DB.query('DELETE FROM _migrations');
                currentVersion = 0;
            }

            // Run pending migrations
            for (let i = currentVersion; i < migrations.length; i++) {
                try {
                    await DB.query(migrations[i]);
                } catch (e) {
                    // Ignore "already exists" errors for idempotency
                    const msg = e.message.toLowerCase();
                    if (!msg.includes('duplicate column') && !msg.includes('already exists')) {
                        throw e;
                    }
                }
                // Use INSERT OR REPLACE to handle re-running migrations
                await DB.query(`INSERT OR REPLACE INTO _migrations (version) VALUES (${i + 1})`);
            }
        }

        // ============ Goals CRUD ============
        async function getGoals(includeArchived = false) {
            const where = includeArchived ? '' : 'WHERE archived = 0';
            const result = await DB.query(`SELECT * FROM goals ${where} ORDER BY archived, position, id`);
            return result.rows ? result.rows.map(row => ({
                id: Number(row[0]),
                name: row[1],
                frequency: row[2],
                position: Number(row[3]),
                archived: Number(row[4]),
                created_at: row[5],
                updated_at: row[6]
            })) : [];
        }

        async function createGoal(name, frequency) {
            const maxPosResult = await DB.query('SELECT MAX(position) FROM goals WHERE archived = 0');
            const maxPos = (maxPosResult.rows && maxPosResult.rows[0][0]) || 0;

            await DB.query(`INSERT INTO goals (name, frequency, position) VALUES (
                '${escapeSQL(name)}', '${escapeSQL(frequency)}', ${maxPos + 1}
            )`);
        }

        async function updateGoal(id, name, frequency) {
            await DB.query(`UPDATE goals SET
                name = '${escapeSQL(name)}',
                frequency = '${escapeSQL(frequency)}',
                updated_at = CURRENT_TIMESTAMP
                WHERE id = ${id}`);
        }

        async function archiveGoal(id) {
            await DB.query(`UPDATE goals SET archived = 1, updated_at = CURRENT_TIMESTAMP WHERE id = ${id}`);
        }

        async function unarchiveGoal(id) {
            const maxPosResult = await DB.query('SELECT MAX(position) FROM goals WHERE archived = 0');
            const maxPos = (maxPosResult.rows && maxPosResult.rows[0][0]) || 0;

            await DB.query(`UPDATE goals SET
                archived = 0,
                position = ${maxPos + 1},
                updated_at = CURRENT_TIMESTAMP
                WHERE id = ${id}`);
        }

        async function reorderGoals(orderedIds) {
            for (let i = 0; i < orderedIds.length; i++) {
                await DB.query(`UPDATE goals SET position = ${i} WHERE id = ${orderedIds[i]}`);
            }
        }

        // ============ Completions CRUD ============
        async function getCompletionsForDate(dateStr) {
            const utcDate = localToUTC(dateStr);
            const result = await DB.query(`SELECT c.*, g.name, g.frequency FROM completions c
                JOIN goals g ON c.goal_id = g.id
                WHERE c.date = '${utcDate}'`);
            return result.rows ? result.rows.map(row => ({
                id: Number(row[0]),
                goal_id: Number(row[1]),
                date: row[2],
                note: row[3],
                created_at: row[4],
                updated_at: row[5],
                checked: Number(row[6]),
                goal_name: row[7],
                goal_frequency: row[8]
            })) : [];
        }

        async function toggleCompletion(goalId, dateStr, note = null) {
            const utcDate = localToUTC(dateStr);

            // Check if checked completion exists
            const existing = await DB.query(`SELECT id, checked FROM completions
                WHERE goal_id = ${goalId} AND date = '${utcDate}'`);

            if (existing.rows && existing.rows.length > 0) {
                const isChecked = Number(existing.rows[0][1]);
                if (isChecked) {
                    // Unchecking: delete the completion entirely
                    await DB.query(`DELETE FROM completions WHERE goal_id = ${goalId} AND date = '${utcDate}'`);
                    return false;
                } else {
                    // Has note but unchecked, now checking it
                    await DB.query(`UPDATE completions SET checked = 1, updated_at = CURRENT_TIMESTAMP
                        WHERE goal_id = ${goalId} AND date = '${utcDate}'`);
                    return true;
                }
            } else {
                // Create new checked completion
                const noteValue = note ? `'${escapeSQL(note)}'` : 'NULL';
                await DB.query(`INSERT INTO completions (goal_id, date, note, checked)
                    VALUES (${goalId}, '${utcDate}', ${noteValue}, 1)`);
                return true;
            }
        }

        async function updateCompletionNote(goalId, dateStr, note) {
            const utcDate = localToUTC(dateStr);
            // Check if record exists
            const existing = await DB.query(`SELECT id, checked FROM completions
                WHERE goal_id = ${goalId} AND date = '${utcDate}'`);

            if (existing.rows && existing.rows.length > 0) {
                // Update existing record
                if (note) {
                    await DB.query(`UPDATE completions SET
                        note = '${escapeSQL(note)}',
                        updated_at = CURRENT_TIMESTAMP
                        WHERE goal_id = ${goalId} AND date = '${utcDate}'`);
                } else {
                    // If clearing note and not checked, delete record
                    const isChecked = Number(existing.rows[0][1]);
                    if (!isChecked) {
                        await DB.query(`DELETE FROM completions WHERE goal_id = ${goalId} AND date = '${utcDate}'`);
                    } else {
                        await DB.query(`UPDATE completions SET
                            note = NULL,
                            updated_at = CURRENT_TIMESTAMP
                            WHERE goal_id = ${goalId} AND date = '${utcDate}'`);
                    }
                }
            } else if (note) {
                // Create new record with note (unchecked)
                await DB.query(`INSERT INTO completions (goal_id, date, note, checked)
                    VALUES (${goalId}, '${utcDate}', '${escapeSQL(note)}', 0)`);
            }
        }

        async function getCompletionsForYear(year) {
            const startDate = `${year}-01-01`;
            const endDate = `${year}-12-31`;
            const result = await DB.query(`SELECT goal_id, date, note, checked FROM completions
                WHERE date >= '${startDate}' AND date <= '${endDate}'
                ORDER BY date`);
            return result.rows ? result.rows.map(row => ({
                goal_id: Number(row[0]),
                date: row[1],
                note: row[2],
                checked: Number(row[3])
            })) : [];
        }

        async function getYearsWithData() {
            const result = await DB.query(`SELECT DISTINCT substr(date, 1, 4) as year
                FROM completions ORDER BY year DESC`);
            return result.rows ? result.rows.map(row => parseInt(row[0])) : [];
        }

        // ============ UI State ============
        let currentDate = getLocalDate();
        let goals = [];
        let completions = [];
        let draggedItem = null;

        // ============ Screen Management ============
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function showModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }

        function hideModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // ============ Setup Screen ============
        document.getElementById('setup-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const url = document.getElementById('db-url').value.trim();
            const token = document.getElementById('api-token').value.trim();

            try {
                DB.saveConfig(url, token);
                await tryConnect();
            } catch (e) {
                showError(e.message);
            }
        });

        async function tryConnect() {
            try {
                await runMigrations();
                await handleRoute();
            } catch (e) {
                console.error('Connection error:', e);
                showError(e.message);
            }
        }

        function showError(message) {
            document.getElementById('error-message').textContent = message;
            showScreen('error-screen');
        }

        document.getElementById('retry-btn').addEventListener('click', async () => {
            const retryBtn = document.getElementById('retry-btn');
            retryBtn.disabled = true;
            retryBtn.textContent = 'Connecting...';

            try {
                await tryConnect();
            } finally {
                retryBtn.disabled = false;
                retryBtn.textContent = 'Try again';
            }
        });

        document.getElementById('change-db-btn').addEventListener('click', () => {
            // Clear form fields so user can enter new credentials
            document.getElementById('db-url').value = '';
            document.getElementById('api-token').value = '';
            showScreen('setup-screen');
        });

        // ============ Main Screen ============
        async function loadMainScreen() {
            showScreen('main-screen');
            await refreshChecklist();
            await refreshStreakCharts();
        }

        async function refreshChecklist() {
            goals = await getGoals();
            completions = await getCompletionsForDate(currentDate);

            document.getElementById('date-picker').value = currentDate;
            document.getElementById('date-day-label').textContent = getDayOfWeek(currentDate);

            const container = document.getElementById('checklist');

            if (goals.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <svg class="empty-state-icon"><use href="#icon-clipboard"/></svg>
                        <div class="empty-state-title">No habits yet</div>
                        <div class="empty-state-text">Start tracking something meaningful</div>
                        <a href="#goals" class="btn">Add your first goal</a>
                    </div>
                `;
                return;
            }

            // Filter goals based on frequency and date
            const applicableGoals = goals.filter(goal => {
                // All goals are applicable (user can complete any time)
                return true;
            });

            container.innerHTML = applicableGoals.map(goal => {
                const completion = completions.find(c => c.goal_id === goal.id);
                const isChecked = completion?.checked === 1;
                const noteValue = completion?.note || '';

                return `
                    <div class="checklist-item ${isChecked ? 'completed' : ''}" data-goal-id="${goal.id}">
                        <div class="checklist-checkbox" onclick="toggleGoal(${goal.id})" tabindex="0" role="checkbox" aria-checked="${isChecked}" aria-label="${escapeHtml(goal.name)}">
                            ${isChecked ? '<svg><use href="#icon-check"/></svg>' : ''}
                        </div>
                        <div class="checklist-content">
                            <div class="checklist-name-row">
                                <div class="checklist-name">${escapeHtml(goal.name)}</div>
                                <div class="note-edit-icon" onclick="startEditNote(${goal.id})" title="Add note">
                                    <svg><use href="#icon-edit"/></svg>
                                </div>
                            </div>
                            <div class="checklist-frequency">${goal.frequency}</div>
                            <div class="note-display" onclick="startEditNote(${goal.id})" data-goal-id="${goal.id}" style="${noteValue ? '' : 'display: none;'}">
                                ${noteValue ? renderMarkdown(noteValue) : ''}
                            </div>
                            <div class="note-inline-editor" data-goal-id="${goal.id}" style="display: none;">
                                <textarea placeholder="Add note (markdown supported)..." data-original="${escapeHtml(noteValue)}">${escapeHtml(noteValue)}</textarea>
                                <div class="note-actions" style="display: none;">
                                    <button class="btn btn-secondary" onclick="cancelEditNote(${goal.id})">Cancel</button>
                                    <button class="btn" onclick="saveNote(${goal.id})">Save</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        window.toggleGoal = async function(goalId) {
            const isNowCompleted = await toggleCompletion(goalId, currentDate);
            await refreshChecklist();
            await refreshStreakCharts();
        };

        window.startEditNote = function(goalId) {
            const editor = document.querySelector(`.note-inline-editor[data-goal-id="${goalId}"]`);
            const display = document.querySelector(`.note-display[data-goal-id="${goalId}"]`);
            if (editor) {
                if (display) display.style.display = 'none';
                editor.style.display = 'block';
                const textarea = editor.querySelector('textarea');
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                setupNoteInputListener(goalId);
            }
        };

        window.cancelEditNote = function(goalId) {
            const editor = document.querySelector(`.note-inline-editor[data-goal-id="${goalId}"]`);
            const display = document.querySelector(`.note-display[data-goal-id="${goalId}"]`);
            if (editor) {
                const textarea = editor.querySelector('textarea');
                const originalNote = textarea.dataset.original || '';
                textarea.value = originalNote;
                editor.querySelector('.note-actions').style.display = 'none';
                editor.style.display = 'none';
                // Only show display if there's a note
                if (display) display.style.display = originalNote ? 'block' : 'none';
            }
        };

        window.saveNote = async function(goalId) {
            const editor = document.querySelector(`.note-inline-editor[data-goal-id="${goalId}"]`);
            if (editor) {
                const textarea = editor.querySelector('textarea');
                await updateCompletionNote(goalId, currentDate, textarea.value);
                await refreshChecklist();
            }
        };

        function setupNoteInputListener(goalId) {
            const editor = document.querySelector(`.note-inline-editor[data-goal-id="${goalId}"]`);
            if (editor) {
                const textarea = editor.querySelector('textarea');
                const actions = editor.querySelector('.note-actions');
                textarea.oninput = function() {
                    const hasChanged = textarea.value !== (textarea.dataset.original || '');
                    actions.style.display = hasChanged ? 'flex' : 'none';
                };
            }
        }

        // Date picker
        document.getElementById('date-picker').addEventListener('change', (e) => {
            currentDate = e.target.value;
            refreshChecklist();
        });

        // Date navigation arrows
        document.getElementById('date-prev').addEventListener('click', () => {
            const date = parseLocalDate(currentDate);
            date.setDate(date.getDate() - 1);
            currentDate = getLocalDate(date);
            refreshChecklist();
        });

        document.getElementById('date-next').addEventListener('click', () => {
            const date = parseLocalDate(currentDate);
            date.setDate(date.getDate() + 1);
            currentDate = getLocalDate(date);
            refreshChecklist();
        });

        // Auto-navigate to current day when tab regains focus after date change
        let lastKnownDate = getLocalDate();
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
                const today = getLocalDate();
                if (today !== lastKnownDate) {
                    lastKnownDate = today;
                    // Only auto-navigate if we're on the main screen
                    if (document.getElementById('main-screen').classList.contains('active')) {
                        currentDate = today;
                        await refreshChecklist();
                        await refreshStreakCharts();
                    }
                }
            }
        });

        // ============ Streak Charts ============
        async function refreshStreakCharts() {
            const year = new Date().getFullYear();
            document.getElementById('current-year-title').textContent = `${year} Progress`;

            const yearCompletions = await getCompletionsForYear(year);
            const container = document.getElementById('streak-charts');

            if (goals.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = goals.map(goal => {
                const goalCompletions = yearCompletions.filter(c => c.goal_id === goal.id);
                return renderStreakChart(goal, goalCompletions, year);
            }).join('');

            // Year links
            const years = await getYearsWithData();
            const otherYears = years.filter(y => y !== year);
            const linksContainer = document.getElementById('year-links');

            if (otherYears.length > 0) {
                linksContainer.innerHTML = '<strong>Previous years:</strong>' +
                    otherYears.map(y => `<a href="#year/${y}">${y}</a>`).join('');
                linksContainer.style.display = 'block';
            } else {
                linksContainer.style.display = 'none';
            }
        }

        function renderStreakChart(goal, completions, year) {
            // Create map of date -> completion (with note)
            const completionMap = {};
            completions.forEach(c => {
                completionMap[c.date] = c;
            });

            const today = new Date();
            const todayStr = getLocalDate(today);
            let cells = '';
            let count = 0;
            let total = 0;

            if (goal.frequency === 'daily') {
                // 7-row grid like GitHub: rows are days of week, columns are weeks
                const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
                const daysInYear = isLeapYear ? 366 : 365;

                // Add placeholder cells for days before Jan 1
                const jan1 = new Date(year, 0, 1);
                const startDayOfWeek = jan1.getDay(); // 0 = Sunday
                for (let i = 0; i < startDayOfWeek; i++) {
                    cells += `<div class="streak-cell placeholder"></div>`;
                }

                for (let day = 1; day <= daysInYear; day++) {
                    const date = new Date(year, 0, day);
                    const dateStr = getLocalDate(date);
                    const utcDate = localToUTC(dateStr);
                    const isFuture = date > today;
                    const isToday = dateStr === todayStr;
                    const completion = completionMap[utcDate];
                    const isChecked = completion?.checked === 1;
                    const hasNote = !!completion?.note;

                    if (!isFuture) total++;
                    if (isChecked) count++;

                    const noteAttr = completion?.note ? `data-note="${escapeHtml(completion.note)}"` : '';
                    const classes = [
                        'streak-cell',
                        isChecked ? 'filled' : '',
                        !isChecked && hasNote ? 'has-note' : '',
                        isFuture ? 'future' : (!isChecked && !hasNote && !isFuture ? 'missed' : ''),
                        isToday ? 'today' : ''
                    ].filter(Boolean).join(' ');

                    const statusLabel = isChecked ? 'completed' : (hasNote ? 'note only' : (isFuture ? 'future' : 'not completed'));
                    cells += `<div class="${classes}" data-date="${dateStr}" ${noteAttr}
                        onclick="showStreakPopover(event, this)"
                        title="${dateStr}"
                        aria-label="${dateStr}: ${statusLabel}"></div>`;
                }
            } else if (goal.frequency === 'weekly') {
                // 52 cells
                for (let week = 1; week <= 52; week++) {
                    const weekDate = new Date(year, 0, (week - 1) * 7 + 4);
                    const isFuture = weekDate > today;

                    // Check if any date in this week is completed, collect notes
                    let isChecked = false;
                    let hasNote = false;
                    let weekNotes = [];
                    for (let d = 0; d < 7; d++) {
                        const checkDate = new Date(year, 0, (week - 1) * 7 + d + 1);
                        const utcDate = localToUTC(getLocalDate(checkDate));
                        const completion = completionMap[utcDate];
                        if (completion) {
                            if (completion.checked === 1) isChecked = true;
                            if (completion.note) {
                                hasNote = true;
                                weekNotes.push(completion.note);
                            }
                        }
                    }

                    if (!isFuture) total++;
                    if (isChecked) count++;

                    const weekStart = new Date(year, 0, (week - 1) * 7 + 1);
                    const weekLabel = `Week ${week} (${weekStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })})`;
                    const noteAttr = weekNotes.length > 0 ? `data-note="${escapeHtml(weekNotes.join('\n\n'))}"` : '';
                    const classes = [
                        'streak-cell',
                        isChecked ? 'filled' : '',
                        !isChecked && hasNote ? 'has-note' : '',
                        isFuture ? 'future' : (!isChecked && !hasNote && !isFuture ? 'missed' : '')
                    ].filter(Boolean).join(' ');

                    const statusLabel = isChecked ? 'completed' : (hasNote ? 'note only' : (isFuture ? 'future' : 'not completed'));
                    cells += `<div class="${classes}" data-date="${weekLabel}" ${noteAttr}
                        onclick="showStreakPopover(event, this)"
                        title="${weekLabel}"
                        aria-label="${weekLabel}: ${statusLabel}"></div>`;
                }
            } else {
                // Monthly - 12 cells
                for (let month = 0; month < 12; month++) {
                    const monthDate = new Date(year, month, 15);
                    const isFuture = monthDate > today;

                    // Check if any date in this month is completed, collect notes
                    let isChecked = false;
                    let hasNote = false;
                    let monthNotes = [];
                    const daysInMonth = new Date(year, month + 1, 0).getDate();
                    for (let d = 1; d <= daysInMonth; d++) {
                        const checkDate = new Date(year, month, d);
                        const utcDate = localToUTC(getLocalDate(checkDate));
                        const completion = completionMap[utcDate];
                        if (completion) {
                            if (completion.checked === 1) isChecked = true;
                            if (completion.note) {
                                hasNote = true;
                                monthNotes.push(completion.note);
                            }
                        }
                    }

                    if (!isFuture) total++;
                    if (isChecked) count++;

                    const monthName = new Date(year, month).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    const noteAttr = monthNotes.length > 0 ? `data-note="${escapeHtml(monthNotes.join('\n\n'))}"` : '';
                    const classes = [
                        'streak-cell',
                        isChecked ? 'filled' : '',
                        !isChecked && hasNote ? 'has-note' : '',
                        isFuture ? 'future' : (!isChecked && !hasNote && !isFuture ? 'missed' : '')
                    ].filter(Boolean).join(' ');

                    const statusLabel = isChecked ? 'completed' : (hasNote ? 'note only' : (isFuture ? 'future' : 'not completed'));
                    cells += `<div class="${classes}" data-date="${monthName}" ${noteAttr}
                        onclick="showStreakPopover(event, this)"
                        title="${monthName}"
                        aria-label="${monthName}: ${statusLabel}"></div>`;
                }
            }

            return `
                <div class="streak-chart">
                    <div class="streak-title">
                        <h3>${escapeHtml(goal.name)}</h3>
                        <span class="streak-count"><span class="numerator">${count}</span><span class="denominator">/${total}</span></span>
                    </div>
                    <div class="streak-grid ${goal.frequency}">${cells}</div>
                </div>
            `;
        }

        // ============ Streak Popover ============
        window.showStreakPopover = function(event, element) {
            event.stopPropagation();

            const date = element.dataset.date;
            const note = element.dataset.note;
            const isFilled = element.classList.contains('filled');
            const hasNoteOnly = element.classList.contains('has-note');

            const popover = document.getElementById('streak-popover');
            const dateEl = document.getElementById('popover-date');
            const contentEl = document.getElementById('popover-content');

            dateEl.textContent = date;

            if (note) {
                const prefix = hasNoteOnly ? '<div class="streak-popover-empty">Not completed</div>' : '';
                contentEl.innerHTML = `${prefix}<div class="streak-popover-note">${renderMarkdown(note)}</div>`;
            } else if (isFilled) {
                contentEl.innerHTML = `<div class="streak-popover-empty">Completed (no note)</div>`;
            } else if (element.classList.contains('future')) {
                contentEl.innerHTML = `<div class="streak-popover-empty">Future</div>`;
            } else {
                contentEl.innerHTML = `<div class="streak-popover-empty">Not completed</div>`;
            }

            // Position the popover near the click
            const rect = element.getBoundingClientRect();
            const popoverWidth = 280;
            const popoverHeight = 100; // approximate

            let left = rect.left + rect.width / 2 - popoverWidth / 2;
            let top = rect.bottom + 8;

            // Keep within viewport
            if (left < 10) left = 10;
            if (left + popoverWidth > window.innerWidth - 10) {
                left = window.innerWidth - popoverWidth - 10;
            }

            // If too close to bottom, show above
            if (top + popoverHeight > window.innerHeight - 10) {
                top = rect.top - popoverHeight - 8;
            }

            popover.style.left = left + 'px';
            popover.style.top = top + 'px';
            popover.classList.add('active');
        };

        // Close popover when clicking outside
        document.addEventListener('click', (e) => {
            const popover = document.getElementById('streak-popover');
            if (!popover.contains(e.target) && !e.target.classList.contains('streak-cell')) {
                popover.classList.remove('active');
            }
        });

        // Close popover on scroll
        document.addEventListener('scroll', () => {
            document.getElementById('streak-popover').classList.remove('active');
        }, true);

        // ============ Goals Management ============
        async function loadGoalsScreen() {
            showScreen('goals-screen');
            await refreshGoalsList();
        }

        async function refreshGoalsList() {
            const allGoals = await getGoals(true);
            const activeGoals = allGoals.filter(g => !g.archived);
            const archivedGoals = allGoals.filter(g => g.archived);

            const container = document.getElementById('goals-list');

            if (activeGoals.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <svg class="empty-state-icon"><use href="#icon-clipboard"/></svg>
                        <div class="empty-state-title">No goals yet</div>
                        <div class="empty-state-text">Add your first goal to get started</div>
                    </div>
                `;
            } else {
                container.innerHTML = activeGoals.map(goal => `
                    <div class="goal-item" data-goal-id="${goal.id}" draggable="true">
                        <span class="drag-handle">
                            <svg style="width: 20px; height: 20px;"><use href="#icon-drag"/></svg>
                        </span>
                        <div class="goal-info">
                            <div class="goal-name">${escapeHtml(goal.name)}</div>
                            <div class="goal-frequency">${goal.frequency}</div>
                        </div>
                        <div class="goal-actions">
                            <button class="btn btn-secondary btn-small" onclick="editGoal(${goal.id})">Edit</button>
                            <button class="btn btn-secondary btn-small" onclick="confirmArchive(${goal.id})">Archive</button>
                        </div>
                    </div>
                `).join('');

                setupDragAndDrop();
            }

            // Archived goals
            const archivedContainer = document.getElementById('archived-goals');
            const archiveToggle = document.getElementById('archive-toggle');

            if (archivedGoals.length > 0) {
                archiveToggle.style.display = 'inline-flex';
                archiveToggle.querySelector('span').textContent = `Show archived (${archivedGoals.length})`;
                archivedContainer.innerHTML = `
                    <div class="archive-divider"><span>Archived</span></div>
                ` + archivedGoals.map(goal => `
                    <div class="goal-item archived" data-goal-id="${goal.id}">
                        <div class="goal-info">
                            <div class="goal-name">${escapeHtml(goal.name)}</div>
                            <div class="goal-frequency">${goal.frequency}</div>
                        </div>
                        <div class="goal-actions">
                            <button class="btn btn-secondary btn-small" onclick="confirmUnarchive(${goal.id})">Unarchive</button>
                        </div>
                    </div>
                `).join('');
            } else {
                archiveToggle.style.display = 'none';
                archivedContainer.style.display = 'none';
                archivedContainer.innerHTML = '';
            }
        }

        document.getElementById('archive-toggle').addEventListener('click', () => {
            const container = document.getElementById('archived-goals');
            const toggle = document.getElementById('archive-toggle');
            if (container.style.display === 'none') {
                container.style.display = 'block';
                toggle.classList.add('expanded');
                toggle.querySelector('span').textContent = 'Hide archived';
            } else {
                container.style.display = 'none';
                toggle.classList.remove('expanded');
                // Re-count archived goals
                const count = container.querySelectorAll('.goal-item').length;
                toggle.querySelector('span').textContent = `Show archived (${count})`;
            }
        });

        // Drag and drop
        function setupDragAndDrop() {
            const items = document.querySelectorAll('.goal-item[draggable="true"]');

            items.forEach(item => {
                // Mouse events
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragleave', handleDragLeave);

                // Touch events for iOS (long press to drag)
                const handle = item.querySelector('.drag-handle');
                handle.addEventListener('touchstart', handleTouchStart);
                handle.addEventListener('touchmove', handleTouchMove, { passive: false });
                handle.addEventListener('touchend', handleTouchEnd);
                handle.addEventListener('touchcancel', handleTouchEnd);
            });
        }

        function handleDragStart(e) {
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd() {
            this.classList.remove('dragging');
            document.querySelectorAll('.goal-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            saveGoalOrder();
        }

        function handleDragOver(e) {
            e.preventDefault();
            if (this !== draggedItem) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave() {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            if (this !== draggedItem) {
                const container = document.getElementById('goals-list');
                const items = [...container.querySelectorAll('.goal-item')];
                const fromIndex = items.indexOf(draggedItem);
                const toIndex = items.indexOf(this);

                if (fromIndex < toIndex) {
                    this.parentNode.insertBefore(draggedItem, this.nextSibling);
                } else {
                    this.parentNode.insertBefore(draggedItem, this);
                }
            }
            this.classList.remove('drag-over');
        }

        // Touch drag and drop for iOS (long press to activate)
        let touchStartY = 0;
        let touchStartX = 0;
        let touchCurrentItem = null;
        let longPressTimer = null;
        let isDragging = false;
        const LONG_PRESS_DURATION = 400; // ms
        const MOVE_THRESHOLD = 10; // px - cancel if moved more than this before long press

        function handleTouchStart(e) {
            const item = this.closest('.goal-item');
            touchCurrentItem = item;
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            isDragging = false;

            // Start long press timer
            longPressTimer = setTimeout(() => {
                // Activate drag mode
                isDragging = true;
                draggedItem = item;
                item.classList.add('dragging');
                // Haptic feedback if available
                if (navigator.vibrate) navigator.vibrate(50);
            }, LONG_PRESS_DURATION);
        }

        function handleTouchMove(e) {
            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartX);
            const deltaY = Math.abs(touch.clientY - touchStartY);

            // If moved too much before long press, cancel (user is scrolling)
            if (!isDragging && (deltaX > MOVE_THRESHOLD || deltaY > MOVE_THRESHOLD)) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
                return; // Allow default scroll behavior
            }

            // If dragging, handle the drag
            if (isDragging) {
                e.preventDefault();
                const items = [...document.querySelectorAll('.goal-item:not(.dragging)')];

                items.forEach(item => {
                    const rect = item.getBoundingClientRect();
                    if (touch.clientY > rect.top && touch.clientY < rect.bottom) {
                        item.classList.add('drag-over');
                    } else {
                        item.classList.remove('drag-over');
                    }
                });
            }
        }

        function handleTouchEnd(e) {
            // Clear long press timer if still pending
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }

            if (!isDragging || !draggedItem) {
                isDragging = false;
                return;
            }

            const overItem = document.querySelector('.goal-item.drag-over');
            if (overItem && overItem !== draggedItem) {
                const container = document.getElementById('goals-list');
                const items = [...container.querySelectorAll('.goal-item')];
                const fromIndex = items.indexOf(draggedItem);
                const toIndex = items.indexOf(overItem);

                if (fromIndex < toIndex) {
                    overItem.parentNode.insertBefore(draggedItem, overItem.nextSibling);
                } else {
                    overItem.parentNode.insertBefore(draggedItem, overItem);
                }
            }

            draggedItem.classList.remove('dragging');
            document.querySelectorAll('.goal-item').forEach(item => {
                item.classList.remove('drag-over');
            });

            saveGoalOrder();
            draggedItem = null;
            isDragging = false;
        }

        async function saveGoalOrder() {
            const items = document.querySelectorAll('#goals-list .goal-item');
            const orderedIds = [...items].map(item => parseInt(item.dataset.goalId));
            await reorderGoals(orderedIds);
        }

        // Goal CRUD UI

        // Frequency toggle helpers
        function setFrequency(value) {
            document.querySelectorAll('#goal-frequency .toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === value);
            });
        }

        function getFrequency() {
            const active = document.querySelector('#goal-frequency .toggle-btn.active');
            return active ? active.dataset.value : 'daily';
        }

        // Toggle button click handlers
        document.querySelectorAll('#goal-frequency .toggle-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setFrequency(btn.dataset.value);
            });
        });

        document.getElementById('add-goal-btn').addEventListener('click', () => {
            document.getElementById('goal-modal-title').textContent = 'Add goal';
            document.getElementById('goal-id').value = '';
            document.getElementById('goal-name').value = '';
            setFrequency('daily');
            showModal('goal-modal');
        });

        window.editGoal = async function(id) {
            const allGoals = await getGoals(true);
            const goal = allGoals.find(g => g.id === id);
            if (!goal) return;

            document.getElementById('goal-modal-title').textContent = 'Edit goal';
            document.getElementById('goal-id').value = id;
            document.getElementById('goal-name').value = goal.name;
            setFrequency(goal.frequency);
            showModal('goal-modal');
        };

        document.getElementById('cancel-goal-btn').addEventListener('click', () => {
            hideModal('goal-modal');
        });

        document.getElementById('goal-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const id = document.getElementById('goal-id').value;
            const name = document.getElementById('goal-name').value.trim();
            const frequency = getFrequency();

            if (id) {
                await updateGoal(parseInt(id), name, frequency);
            } else {
                await createGoal(name, frequency);
            }

            hideModal('goal-modal');
            await refreshGoalsList();
            goals = await getGoals(); // Refresh for main screen
        });

        // Confirm dialogs
        let confirmCallback = null;

        window.confirmArchive = function(id) {
            document.getElementById('confirm-title').textContent = 'Archive goal';
            document.getElementById('confirm-message').textContent = 'Are you sure you want to archive this goal? You can unarchive it later.';
            document.getElementById('confirm-ok').textContent = 'Archive';
            document.getElementById('confirm-ok').className = 'btn btn-danger';
            confirmCallback = async () => {
                await archiveGoal(id);
                await refreshGoalsList();
                goals = await getGoals();
            };
            showModal('confirm-modal');
        };

        window.confirmUnarchive = function(id) {
            document.getElementById('confirm-title').textContent = 'Unarchive goal';
            document.getElementById('confirm-message').textContent = 'This will restore the goal to your active list.';
            document.getElementById('confirm-ok').textContent = 'Unarchive';
            document.getElementById('confirm-ok').className = 'btn';
            confirmCallback = async () => {
                await unarchiveGoal(id);
                await refreshGoalsList();
                goals = await getGoals();
            };
            showModal('confirm-modal');
        };

        document.getElementById('confirm-cancel').addEventListener('click', () => {
            hideModal('confirm-modal');
            // Reset button styles
            document.getElementById('confirm-ok').textContent = 'Confirm';
            document.getElementById('confirm-ok').className = 'btn btn-danger';
        });

        document.getElementById('confirm-ok').addEventListener('click', async () => {
            if (confirmCallback) {
                await confirmCallback();
                confirmCallback = null;
            }
            hideModal('confirm-modal');
            // Reset button styles
            document.getElementById('confirm-ok').textContent = 'Confirm';
            document.getElementById('confirm-ok').className = 'btn btn-danger';
        });

        // ============ Year View ============
        async function loadYearScreen(year) {
            document.getElementById('year-title').textContent = `${year} Progress`;
            showScreen('year-screen');

            const allGoals = await getGoals(true);
            const yearCompletions = await getCompletionsForYear(year);

            const container = document.getElementById('year-streak-charts');
            container.innerHTML = allGoals.map(goal => {
                const goalCompletions = yearCompletions.filter(c => c.goal_id === goal.id);
                return renderStreakChart(goal, goalCompletions, year);
            }).join('');
        }

        // ============ Routing ============
        async function handleRoute() {
            const hash = window.location.hash.slice(1) || '';
            localStorage.setItem(`${APP_NAME}_last_hash`, hash);

            if (hash === 'goals') {
                await loadGoalsScreen();
            } else if (hash.startsWith('year/')) {
                const year = parseInt(hash.split('/')[1]);
                await loadYearScreen(year);
            } else {
                await loadMainScreen();
            }
        }

        window.addEventListener('hashchange', handleRoute);

        // ============ Initialize ============
        async function init() {
            // Register service worker
            if ('serviceWorker' in navigator) {
                try {
                    await navigator.serviceWorker.register('sw.js');
                } catch (e) {
                    console.log('Service worker registration failed:', e);
                }
            }

            // Check for stored config
            if (DB.init()) {
                // Restore last hash before connecting
                const lastHash = localStorage.getItem(`${APP_NAME}_last_hash`);
                if (lastHash) {
                    window.location.hash = lastHash;
                }
                await tryConnect();
            } else {
                showScreen('setup-screen');
            }
        }

        init();
    </script>
</body>
</html>
